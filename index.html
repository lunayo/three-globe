<head>
  <style>
    body {
      margin: 0;
    }
  </style>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
  <link href="stylesheets/clock.css" rel="stylesheet">

  <script src="//unpkg.com/three"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <script src="https://unpkg.com/@reactivex/rxjs@5.5.11/dist/global/Rx.min.js"></script>
  <script src="https://unpkg.com/rxcss@0.6.0/dist/rxcss.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <!-- <script src="//unpkg.com/three/examples/js/controls/TrackballControls.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>
  <script src="scripts/data.js"></script>
  <script src="dist/three-globe.js"></script>
</head>

<body>
  <div class="time" id="time" data-hours="" data-minutes="">
    <div class="digit">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
    <div class="digit">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
    <div class="digit">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
    <div class="digit">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
  </div>
  <div id="globeViz"></div>
  <div id="videoModal" class="modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Modal title</h5>
        </div>
        <div class="modal-body">
          <div class="embed-responsive embed-responsive-16by9">
            <video controls loop style="width: 100%;height: auto;">
              <source src="" type="video/mp4">
              </source>
            </video>
          </div>
          <p class="description"></p>
        </div>
      </div>
    </div>
  </div>

  <script>

    const Globe = new ThreeGlobe()
      .globeImageUrl('img/earth-blue-marble.jpg')
      .bumpImageUrl('img/earth-topology.png')
      .pointsData(data)
      .pointAltitude(0.08)
      .pointColor(() => '#ffffaa');

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 1, 1); // change light position to see the specularMap's effect

    // Setup renderer
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('globeViz').appendChild(renderer.domElement);

    // Setup scene
    const scene = new THREE.Scene();
    scene.add(Globe);
    scene.add(new THREE.AmbientLight(0xbbbbbb));
    scene.add(directionalLight);

    // Setup camera
    const camera = new THREE.PerspectiveCamera();
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    camera.position.z = 10000;

    const generateStarField = () => {
      const parameters = {};
      parameters.count = 200000;
      parameters.sizeAttenuation = true;
      parameters.radius = 10000;
      parameters.randomness = 3;
      parameters.randomnessPower = 1;
      const colors = ['#C0BDA4', '#486BA6', '#949EAF', '#9A6C40', '#98A8DA', '#5B99D2', '#EFCA8C', '#C2617B'];
      const textureLoader = new THREE.TextureLoader();
      const particleTexture = textureLoader.load('img/textures/particles.png');
      const startsPositions = new Float32Array(parameters.count * 3);
      const starsColors = new Float32Array(parameters.count * 3);

      for (let i = 0; i < parameters.count; i++) {
        const i3 = i * 3;
        const insideColor = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
        const outsideColor = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
        const radius = Math.random() * parameters.radius;

        let randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : - 1) * parameters.randomness * radius;
        let randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : - 1) * parameters.randomness * radius;
        let randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : - 1) * parameters.randomness * radius;

        let radiusThreshold = 1000;
        let position = new THREE.Vector3(randomX, randomY, randomZ);
        let distance = position.distanceTo(new THREE.Vector3(0, 0, 0));
        if (distance < radiusThreshold) {
          continue;
        }

        startsPositions[i3] = randomX;
        startsPositions[i3 + 1] = randomY;
        startsPositions[i3 + 2] = randomZ;

        //color
        const mixedColor = insideColor.clone();
        mixedColor.lerp(outsideColor, radius / parameters.radius);

        starsColors[i3 + 0] = mixedColor.r;
        starsColors[i3 + 1] = mixedColor.g;
        starsColors[i3 + 2] = mixedColor.b;
      }

      const geometry = new THREE.BufferGeometry({});
      geometry.setAttribute('position', new THREE.BufferAttribute(startsPositions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(starsColors, 3));

      const size = (Math.random() + 1) * 3;
      const material = new THREE.PointsMaterial({
        size: size,
        sizeAttenuation: parameters.sizeAttenuation,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        transparent: true,
        alphaMap: particleTexture,
      });

      const galaxyPoints = new THREE.Points(
        geometry,
        material,
      );
      scene.add(galaxyPoints);
    }

    generateStarField();

    var VideoModal = function (title = "", description = "", url = "") {
      this.element = document.getElementById('videoModal');
      this.videoModal = new bootstrap.Modal(this.element, {});

      this.title = this.element.getElementsByClassName('modal-title')[0];
      this.title.innerHTML = title;

      this.body = this.element.getElementsByClassName('modal-body')[0];
      this.description = this.body.getElementsByClassName('description')[0];
      this.description.innerHTML = description;

      this.video = this.body.getElementsByTagName('video')[0];
      this.source = this.video.getElementsByTagName('source')[0];
      this.source.setAttribute('src', url);

      this.visible = this.element.classList.contains('show');

      VideoModal.prototype.hide = function () {
        if (this.visible) {
          this.videoModal.hide();
          this.video.pause();
          this.visible = false;
        }
      }

      VideoModal.prototype.show = function () {
        if (!this.visible) {
          this.videoModal.show();
          this.video.load();
          this.video.play();
          this.visible = true;
        }
      }

      VideoModal.prototype.setTitle = function (title) {
        this.title.innerHTML = title;
      }

      VideoModal.prototype.setBody = function (description) {
        this.description.innerHTML = description;
      }

      VideoModal.prototype.setVideoUrl = function (url) {
        this.source.setAttribute('src', url);
      }
    }

    document.onkeydown = checkKey;
    function animatePosition(targetAngle, speed, onUpdate, onComplete) {
      let position = { angle: 0.0 };
      let tween = new TWEEN.Tween(position)
        .easing(TWEEN.Easing.Cubic.InOut)
        .to({ angle: targetAngle }, speed)
        .start();

      tween.onUpdate(function () {
        onUpdate(position.angle);
      }).onComplete(onComplete);
    }
    function animateScale(currentScale, targetScale, speed, onUpdate, onComplete) {
      let scale = Object.assign(currentScale);
      let tween = new TWEEN.Tween(scale)
        .easing(TWEEN.Easing.Cubic.InOut)
        .to(targetScale, speed)
        .start();

      tween.onUpdate(function () {
        onUpdate(scale);
      }).onComplete(onComplete);
    }

    function getPinPoints() {
      const rootLayer = scene.children[0].children[0];
      const pointsLayer = rootLayer.children.filter(obj => obj.name == 'pointsLayer');
      return pointsLayer[0].children;
    }

    function triggerPinUnfocus(callback) {
      const points = getPinPoints();
      for (let i = 0; i < points.length; ++i) {
        if (points[i]) {
          animateScale(
            { pinScale: points[i].children[1].scale.x, glowScale: points[i].children[2].scale.x },
            { pinScale: 1, glowScale: 1.2 },
            800, function (scalar) {
              if (points[i]) {
                points[i].children[1].scale.setScalar(scalar.pinScale);
                points[i].children[2].scale.setScalar(scalar.glowScale);
              }
            }, callback);
        }
      }
    }

    function getNearestPointToCamera() {
      const points = getPinPoints();
      var curr;
      var nearestDistance = Number.MAX_SAFE_INTEGER;
      for (let i = 0; i < points.length; ++i) {
        var target = new THREE.Vector3();
        points[i].getWorldPosition(target);
        const distance = camera.position.distanceTo(target);
        if (distance < nearestDistance && distance < 191) {
          nearestDistance = distance;
          curr = points[i];
        }
      }
      return curr;
    }

    var currentPoint;
    function triggerPinFocus(point) {
      if (point) {
        currentPoint = point;
        animateScale(
          { pinScale: currentPoint.children[1].scale.x, glowScale: currentPoint.children[2].scale.x },
          { pinScale: 2, glowScale: 2.4 }, 800, function (scalar) {
            if (currentPoint) {
              currentPoint.children[1].scale.setScalar(scalar.pinScale);
              currentPoint.children[2].scale.setScalar(scalar.glowScale);
            }
          });
      }
    }

    function getNearestPoint(direction) {
      if(currentPoint == null) return null;
      const points = getPinPoints();
      var center = new THREE.Vector3();
      currentPoint.getWorldPosition(center);
      const distanceThreshold = 40;
      var filterFunction = function(target, center) {
        if (direction === 'left') {
          return target.x < center.x;
        } else if (direction === 'right')  {
          return target.x > center.x;
        } else if (direction === 'up') {
          return target.y > center.y;
        } else {
          return target.y < center.y;
        }
      }
      var filteredPoints = points.filter(function(point) {
        var target = new THREE.Vector3();
        point.getWorldPosition(target);
        const distance = center.distanceTo(target);
        return point.__title !== currentPoint.__title &&
          filterFunction(target, center) && distance < distanceThreshold;
      });
      
      var candidatePoint = null;
      var currentDistance = Number.MAX_SAFE_INTEGER;
      for(var i=0;i<filteredPoints.length;++i) {
        var target = new THREE.Vector3();
        filteredPoints[i].getWorldPosition(target);
        const distance = center.distanceTo(target);
        if(distance < currentDistance) {
          currentDistance = distance;
          candidatePoint = filteredPoints[i];
        }
      }
      return candidatePoint;
    }

    var modal;
    function checkKey(e) {
      e = e || window.event;
      const currentPosition = { ...camera.position };
      if (modal) {
        modal.hide();
      }
      if (e.keyCode >= 37 && e.keyCode <= 40) {
        triggerPinUnfocus();
        var nearestPoint;
        var angle;
        var rotationFunction;
        if (e.keyCode == '38') {
          // up arrow
          angle = 0.3;
          nearestPoint = getNearestPoint('down');
          const sceneRotation = scene.rotation.x;
          rotationFunction = function(angle) {
            scene.rotation.x = sceneRotation - angle;
          }
        } else if (e.keyCode == '40') {
          // down arrow
          angle = 0.3;
          nearestPoint = getNearestPoint('up');
          const sceneRotation = scene.rotation.x;
          rotationFunction = function(angle) {
            scene.rotation.x = sceneRotation + angle;
          }
        } else if (e.keyCode == '37') {
          // left arrow
          angle = 0.5;
          nearestPoint = getNearestPoint('right');
          const sceneRotation = scene.rotation.y;
          rotationFunction = function(angle) {
            scene.rotation.y = sceneRotation - angle;
          }
        } else if (e.keyCode == '39') {
          // right arrow
          angle = 0.5;
          nearestPoint = getNearestPoint('left');
          const sceneRotation = scene.rotation.y;
          rotationFunction = function(angle) {
            scene.rotation.y = sceneRotation + angle;
          }
        }
        if(nearestPoint) {
          var nearest = new THREE.Vector3();
          nearestPoint.getWorldPosition(nearest);
          var current = new THREE.Vector3();
          currentPoint.getWorldPosition(current);
          nearest = new THREE.Vector3(nearest.x, nearest.y, nearest.z);
          current = new THREE.Vector3(0, nearest.y, nearest.z);
          angle = current.angleTo(nearest);
          currentPoint = nearestPoint;
        }
        animatePosition(angle, 500, function (angle) {
          rotationFunction(angle);
        }, function () {
          if(!nearestPoint) {
            nearestPoint = getNearestPointToCamera();  
          }
          triggerPinFocus(nearestPoint);
        });
      } else if (e.keyCode == '13') {
        // enter key
        if (currentPoint) {
          modal = new VideoModal(currentPoint.__title,
            currentPoint.__description, currentPoint.__url);
          modal.show();
        }
      }
    }

    function setGroupOpacity(group, opacity) {
      group.children.forEach(function (child) {
        setGroupOpacity(child, opacity);
      });
      if (group.material) {
        group.material.opacity = opacity;
      }
    }

    const Timer = function () {
      // Clock
      const timeElm = document.getElementById('time');
      const doc = document.documentElement;
      const { clientWidth, clientHeight } = doc;

      const pad = (val) => val < 10 ? `0${val}` : val;

      const animationFrame$ = Rx.Observable.interval(0, Rx.Scheduler.animationFrame);

      timeElm.style.display = 'none';

      // 3 minutes countdown
      const totalTime = 10800;
      const threshold = (totalTime - 2400) / data.length;
      var seconds = totalTime;
      var currentThreshold = threshold;
      var opacity = 1.0;

      function randomRemovePinObject() {
        const rootLayer = scene.children[0].children[0];
        const pointsLayer = rootLayer.children.filter(obj => obj.name == 'pointsLayer');
        const points = pointsLayer[0].children;
        if (points.length > 0) {
          const index = Math.floor(Math.random() * points.length);
          points.splice(index, 1);
        }
      }

      Timer.prototype.hide = function () {
        timeElm.style.display = 'none';
      }

      Timer.prototype.show = function () {
        timeElm.style.display = 'flex';
      }

      Timer.prototype.start = function () {
        this.show();
        const time$ = Rx.Observable
          .interval(1000)
          .map(() => {
            opacity -= 1.0 / 180;
            setGroupOpacity(scene.children[0], opacity);
            if (seconds < totalTime - currentThreshold) {
              randomRemovePinObject();
              currentThreshold += threshold;
            }
            seconds = Math.max(0, seconds - 60);
            return {
              minutes: Math.floor(seconds / 3600),
              seconds: (seconds % 3600) / 60,
            };
          })
          .subscribe(({ hours, minutes, seconds }) => {
            timeElm.setAttribute('data-hours', pad(minutes));
            timeElm.setAttribute('data-minutes', pad(seconds));
          });
      }
    }

    const timer = new Timer();
    var cameraPosition = { z: camera.position.z };
    let tween = new TWEEN.Tween(cameraPosition)
      .easing(TWEEN.Easing.Cubic.InOut)
      .to({ z: 280 }, 5000)
      .start();
    tween.onUpdate(function () {
      camera.position.z = cameraPosition.z;
    }).onComplete(function () {
      timer.start();
      currentPoint = getNearestPointToCamera();
      triggerPinFocus(currentPoint);
    });


    // // Add camera controls
    // const tbControls = new THREE.TrackballControls(camera, renderer.domElement);
    // tbControls.minDistance = 101;
    // tbControls.rotateSpeed = 5;
    // tbControls.zoomSpeed = 0.8;

    // Kick-off renderer
    (function animate() { // IIFE
      // Frame cycle
      // tbControls.update();
      TWEEN.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    })();
  </script>
</body>